상속 (inheritance)
	// 일반적으로 같은 프로젝트 안에서 상속.
	1. 기존에 선언된 클래스의 필드를 새롭게 만들 클래스의 필드로 사용하고자 할 때
	2. 여러 클래스 선언 시 필드가 겹치는 경우, 부모 클래스 먼저 선언 후 공통 필드로 묶어서 자식클래스에게 상속

상속 문법
	class A {
		A필드
	}

	class B extends A {
		(A), B필드 //상속 받았기 때문에 부모클래스에 필드도 가지고 있음
	}

자식 클래스의 객체화 (메모리 할당)
	자식 클래스로 객체를 만들 때 자식 생성자가 호출이 된다.
	단, 항상 부모 생성자가 먼저 호출이 되어 부모 클래스의 정보가 메모리에 먼저 올라가야 한다.
	부모 클래스의 정보를 메모리에 올리는 역할을 하는 것이 부모 생성자이다.
	부모 클래스에 기본 생성자가 정의되어 있다면, 자식 생성자 안에서 생략되어 들어가 있다.
	하지만, 부모 클래스에 기본 생성자가 정의되어있지 않다면
	자식 생성자를 정의할 때 가장 먼저 정의되어있는 부모 생성자를 작성해줘야 한다.


다형성
	메소드의 이름은 같다.
	1. 오버로딩 -> 매개변수가 달라야함.
	2. 오버라이딩 -> 상속 관계가 묶여있을 때 (재정의)
		부모 필드에서 선언한 메소드를 자식 필드에서 수정하고자 할 때 재정의를 해야한다.
		이는 자식에서 부모 필드의 메소드와 동일한 이름으로 선언하는 것
		부모 필드가 메모리에 먼저 할당되고  test라는 메소드가 먼저 올라간다고 가정하면,
		자식 필드가 메모리에 할당되면서 재정의한 test메소드가 새롭게 만들어지는 것이 아닌
		기존에 할당된 test메소드 저장 공간에 새롭게 재정의한 자식 필드의 소스코드가 주소가 추가되는 것
		따라서 자식 객체로 test메소드를 호출하면 자식 필드에서 재정의한 메소드가 실행

======================================================================
종합 실습
	class Animal
		String name;
		int age;
		String species;

		void printInfo(){
			원하는 모양으로 출력
		}

	class SickAnimal <- Animal 클래스 상속
		String disease; // 증상
		
		void printInfo(){
			병명도 함께 출력하기

		}
		
		void cure(){	
			누구의 병명이 잘 치유되었습니다. 출력
		}
========================================================================
Casting (모든 자식은! 부모 타입)
	up casting: 자식 값을 부모 타입으로 형변환 (자식 -> 부모)
	down casting: "up casting"된 객체를 자식 타입으로 형변환 (부모 -> 자식)
	* 부모 값을 자식 타입으로 형 변환 시 오류 발생 (컴파일은 되지만 메모리 누수 오류 발생)


	

























